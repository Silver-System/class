package traversal;
import java.util.*;
public class Prim_MST {
	    int count;
	    private LinkedList <LinkedList<Edge>>Adj;
	    int INF=9999;
	    private static class Edge implements Comparable<Edge>{
	    	private int src;
	    	private int dest;
	    	private int cost;    	
	    
	        public Edge(int s,int dst,int cost) {
	    	    dest=dst;
	    	    src=s;
	    	    this.cost=cost;
	        }
	        public int compareTo(Edge compareEdge) {
	        	return this.cost-compareEdge.cost;
	        }
	    }
	    public Prim_MST(int cnt) {
	    	count=cnt;
	    	Adj=new LinkedList<LinkedList<Edge>>();
	    	for(int i=0;i<cnt;i++) {
	    		Adj.add(new LinkedList<Edge>());
	    	}
	    }
	    public void addDirectedEdge(int source,int dest,int cost) {
	        Edge edge=new Edge(source,dest,cost);
	        Adj.get(source).add(edge);
	    }
	    public void addDirectedEdge(int source,int dest) {
	    	addDirectedEdge(source,dest,1);
	    }
	    public void addUndirectedEdge(int source,int dest,int cost) {
	    	addDirectedEdge(source,dest,cost);
	    	addDirectedEdge(dest,source,cost);
	    }
	    public void addUndirectedEdge(int source,int dest) {
	    	addUndirectedEdge(source,dest,1);
	    }
	    public void print() {
	    	for(int i=0;i<count;i++) {
	    		LinkedList<Edge>ad=Adj.get(i);
	    		System.out.println("\n Vertex "+i+" is connected to: ");
	    		for(Edge adn:ad) {
	    			System.out.println("("+adn.dest+","+adn.cost+")");
	    		}
	    	}
	    }
	    public void primMst() {
	    	int[] previous=new int[count];
	    	int []dist=new int[count];
	    	boolean[] visited=new boolean[count];
	    	Arrays.fill(previous, -1);//Fill all values of predecessor array as -1 or nil
	    	Arrays.fill(dist,Integer.MAX_VALUE);//fill distance array with infinity
	    	int source=0;
	    	dist[source]=0;
	    	previous[source]=source;
	        PriorityQueue<Edge> queue=new PriorityQueue<Edge>(100);
	        Edge node=new Edge(source,source,0);
	        queue.add(node);
	        while(!queue.isEmpty()) {
	        	node=queue.peek();
	        	queue.remove();
	        	visited[source]=true;
	        	source=node.dest;
	        	LinkedList<Edge>ad1=Adj.get(source);
	        	for(Edge adn:ad1) {
	        		int dest=adn.dest;
	        		int alt=adn.cost;
	        		if(dist[dest]>alt && visited[dest]==false) {
	        			dist[dest]=alt;
	        			previous[dest]=source;
	        			node=new Edge(source,dest,alt);
	        			queue.add(node);
	        		}
	        		
	        	}
	        }
	        int sum=0;
	        boolean isMst=true;
	        String output="Edges are";
	        for(int i=0;i<count;i++) {
	        	if(dist[i]==Integer.MAX_VALUE) {
	        		output+=("("+i+", Unreachable)");
	        	}
	        }
	    }

		public static void main(String[] args) {
			// TODO Auto-generated method stub
		
			for(int i=0;i<5;i++) {
				for(int j=i+1;j<5;j++) {
					
					    //gph.addUndirectedEdge(i,j,1);
				}
			}
			//gph.print();

		}

	}

